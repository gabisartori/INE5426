use std::error::Error;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Token {
  ConstChar,
  ConstBool,
  ConstNull,
  Lparenthesis,
  Rparenthesis,
  Lbracket,
  Rbracket,
  Rbrace,
  Lbrace,
  Semicolon,
  Comma,
  VarType,
  KwIf,
  KwElif,
  KwElse,
  KwWhile,
  KwFor,
  KwBreak,
  KwContinue,
  KwReturn,
  KwDef,
  KwPrint,
  KwRead,
  OpAssign,
  OpEq,
  OpNe,
  OpGt,
  OpGe,
  OpLt,
  OpLe,
  OpAnd,
  OpOr,
  OpXor,
  OpNot,
  OpBitwiseAnd,
  OpBitwiseOr,
  OpBitwiseXor,
  OpBitwiseNot,
  OpLBitshift,
  OpRBitshift,
  OpPlus,
  OpMinus,
  OpMult,
  OpDivision,
  OpWholeDivision,
  OpModular,
  OpPow,
  Id,
  ConstInt,
  ConstFloat,
  ConstString,
}

impl Token {
  pub fn from_str(s: &str) -> Result<Token, Box<dyn Error>> {
    match s {
      "const_char" => Ok(Token::ConstChar),
      "const_bool" => Ok(Token::ConstBool),
      "const_null" => Ok(Token::ConstNull),
      "lparenthesis" => Ok(Token::Lparenthesis),
      "rparenthesis" => Ok(Token::Rparenthesis),
      "lbracket" => Ok(Token::Lbracket),
      "rbracket" => Ok(Token::Rbracket),
      "rbrace" => Ok(Token::Lbrace),
      "lbrace" => Ok(Token::Rbrace),
      "semicolon" => Ok(Token::Semicolon),
      "comma" => Ok(Token::Comma),
      "var_type" => Ok(Token::VarType),
      "kw_if" => Ok(Token::KwIf),
      "kw_elif" => Ok(Token::KwElif),
      "kw_else" => Ok(Token::KwElse),
      "kw_while" => Ok(Token::KwWhile),
      "kw_for" => Ok(Token::KwFor),
      "kw_break" => Ok(Token::KwBreak),
      "kw_continue" => Ok(Token::KwContinue),
      "kw_return" => Ok(Token::KwReturn),
      "kw_def" => Ok(Token::KwDef),
      "kw_print" => Ok(Token::KwPrint),
      "kw_read" => Ok(Token::KwRead),
      "op_assign" => Ok(Token::OpAssign),
      "op_eq" => Ok(Token::OpEq),
      "op_ne" => Ok(Token::OpNe),
      "op_gt" => Ok(Token::OpGt),
      "op_ge" => Ok(Token::OpGe),
      "op_lt" => Ok(Token::OpLt),
      "op_le" => Ok(Token::OpLe),
      "op_and" => Ok(Token::OpAnd),
      "op_or" => Ok(Token::OpOr),
      "op_xor" => Ok(Token::OpXor),
      "op_not" => Ok(Token::OpNot),
      "op_bitwise_and" => Ok(Token::OpBitwiseAnd),
      "op_bitwise_or" => Ok(Token::OpBitwiseOr),
      "op_bitwise_xor" => Ok(Token::OpBitwiseXor),
      "op_bitwise_not" => Ok(Token::OpBitwiseNot),
      "op_l_bitshift" => Ok(Token::OpLBitshift),
      "op_r_bitshift" => Ok(Token::OpRBitshift),
      "op_plus" => Ok(Token::OpPlus),
      "op_minus" => Ok(Token::OpMinus),
      "op_mult" => Ok(Token::OpMult),
      "op_division" => Ok(Token::OpDivision),
      "op_whole_division" => Ok(Token::OpWholeDivision),
      "op_modular" => Ok(Token::OpModular),
      "op_pow" => Ok(Token::OpPow),
      "id" => Ok(Token::Id),
      "const_int" => Ok(Token::ConstInt),
      "const_float" => Ok(Token::ConstFloat),
      "const_string" => Ok(Token::ConstString),
      _ => Err(format!("Invalid token: {}", s).into()),
    }
  }
}

pub enum Command {
  Push
}