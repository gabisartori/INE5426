Deve-se provar que a gram√°tica ConvCC-2025-1 G admite uma defini√ß√£o dirigida pela sintaxe L-atribu√≠da (SDD L-atribu√≠da).

Uma defini√ß√£o dirigida pela sintaxe (SDD) √© dita L-atribu√≠da se:

1 - Para cada produ√ß√£o A -> X1, X2,...Xn, qualquer atributo herdado de Xi, i‚àà [1,n] pode depender apenas de atributos herdados ou sintetizados do s√≠mbolo pai A e atributos sintetizados de s√≠mbolos √† esquerda de Xi, ou seja, X1, X2,...Xi-1;
2 - Atributos sintetizados de um s√≠mbolo A podem depender apenas de atributos dos s√≠mbolos X1,...,Xn na produ√ß√£o.
3 - Portanto, G admite uma defini√ß√£o L-atribu√≠da.

Parte 1: A gram√°tica √© compat√≠vel com parsing LL(1):

Seja G = (Vn, Vt, P, S) uma gram√°tica livre de contexto, com:
- Vn: conjunto de n√£o terminais;
- Vt: conjunto de s√≠mbolos terminais;
- P: conjunto de produ√ß√µes;
- S: s√≠mbolo inicial

Dizemos que G √© uma gram√°tica LL(1) se e somente se, para cada n√£o-terminal A ‚àà V e para cada par de produ√ß√µes distintas: A ->  ùõº e A -> ùõΩ, com ùõº != ùõΩ, valem as seguintes condi√ß√µes:
1 - FIRST(ùõº) ‚à© FIRST(ùõΩ)
2 - Se ùúñ ‚àà FIRST(ùõº), ent√£o FIRST(ùõΩ) ‚à© FOLLOW(S) = ‚àÖ
3 - Se ùúñ ‚àà FIRST(ùõΩ), ent√£o FIRST(ùõº) ‚à© FOLLOW(S) = ‚àÖ

Assim, ao examinar o pr√≥ximo token de entrada (lookahead de 1 s√≠mbolo), √© poss√≠vel decidir unicamente qual produ√ß√£o aplicar, requisito para a an√°lise descendente determin√≠stica.

A prova de que a gram√°tica ConvCC-2025-1 G √© LL(1) est√° no arquivo 'grammars/ll1_proof.txt'.

Parte 2 ‚Äî A gram√°tica admite uma defini√ß√£o dirigida pela sintaxe L-atribu√≠da

Seja uma gram√°tica G = (Vn, Vt, P, S). Uma Defini√ß√£o Dirigida pela Sintaxe (SDD) √© dita L-atribu√≠da se, para cada produ√ß√£o da forma: 
A -> X1, X2,...Xn,
e para cada atributo herdado h de algum s√≠mbolo Xi, a fun√ß√£o de avalia√ß√£o de h pode depender somente de atributos (sintetizados ou herdados) de 
- A (o s√≠mbolo do lado esquerdo da produ√ß√£o);
- Atributos sintetizados de X1, X2,...Xi-1 (os irm√£os √† esquerda de Xi).
Estas restri√ß√µes garantem que os atributos podem ser avaliados em uma √∫nica travessia da √°rvore sint√°tica da esquerda para a direita. 

1 - Bloco EXPRESSIONS

Produ√ß√£o:
EXPRESSION -> NUMEXPRESSION EXPRESSION_1

Atributos:
- NUMEXPRESSION.ptr: sintetizado
- EXPRESSION_1.inh: herdado
- EXPRESSION.ptr: sintetizado

 EXPRESSION_1.inh = NUMEXPRESSION.ptr
 EXPRESSION.ptr = EXPRESSION_1.ptr
 
- EXPRESSION_1.inh depende de NUMEXPRESSION.ptr, irm√£o √† esquerda 
- EXPRESSION.ptr depende de EXPRESSION_1.ptr, filho √† direita 

Produ√ß√£o:
EXPRESSION_1 -> OP_EXPRESSION NUMEXPRESSION

Atributos:
- EXPRESSION_1.inh: herdado
- OP_EXPRESSION.ptr: sintetizado
- NUMEXPRESSION.ptr: sintetizado
- EXPRESSION_1.ptr: sintetizado

 EXPRESSION_1.ptr = Node(EXPRESSION, Some(vec![EXPRESSION_1.inh, OP_EXPRESSION.ptr, NUMEXPRESSION.ptr]))

- EXPRESSION_1.ptr depende de:
  - EXPRESSION_1.inh, herdado (do pai) 
  - OP_EXPRESSION.ptr: filho √† esquerda
  - NUMEXPRESSION.ptr: filho √† direita

Produ√ß√£o:
EXPRESSION_1 -> ''

Atributos:
- EXPRESSION_1.inh: herdado
- EXPRESSION_1.ptr: sintetizado

 EXPRESSION_1.ptr = Node(EXPRESSION, Some(vec![EXPRESSION_1.inh]))

EXPRESSION_1.ptr depende apenas do atributo herdado do pai (EXPRESSION_1.inh)

2 - Bloco NUMEXPRESSIONS:

Produ√ß√£o:
NUMEXPRESSION -> TERM NUMEXPRESSION_1

Atributos:
- TERM.ptr: sintetizado
- NUMEXPRESSION_1.inh: herdado
- NUMEXPRESSION.ptr: sintetizado

 NUMEXPRESSION_1.inh = Node(NUMEXPRESSION, vec![TERM.ptr])
 NUMEXPRESSION.ptr = NUMEXPRESSION_1.ptr

- NUMEXPRESSION_1.inh depende de TERM.ptr, irm√£o √† esquerda 
- NUMEXPRESSION.ptr depende de NUMEXPRESSION_1.ptr, filho √† direita

Produ√ß√£o:
NUMEXPRESSION_1 -> OP_NUMEXPRESSION TERM NUMEXPRESSION_1

Atributos:
- NUMEXPRESSION_1.inh: herdado
- OP_NUMEXPRESSION.ptr: sintetizado
- TERM.ptr: sintetizado
- NUMEXPRESSION_1_1.inh: herdado
- NUMEXPRESSION_1.ptr: sintetizado

 NUMEXPRESSION_1_1.inh = Node(NUMEXPRESSION, vec![NUMEXPRESSION_1.inh.children[0], OP_NUMEXPRESSION.ptr, TERM.ptr])
 NUMEXPRESSION_1.ptr = NUMEXPRESSION_1_1.ptr

- NUMEXPRESSION_1_1.inh depende de:
  - NUMEXPRESSION_1.inh (herdado do pai)
  - OP_NUMEXPRESSION.ptr (filho √† esquerda)
  - TERM.ptr (filho √† esquerda de NUMEXPRESSION_1_1)
- NUMEXPRESSION_1.ptr depende de NUMEXPRESSION_1_1.ptr (filho)

Produ√ß√£o:
NUMEXPRESSION_1 -> ''

Atributos
- NUMEXPRESSION_1.inh: herdado
- NUMEXPRESSION_1.ptr: sintetizado

 NUMEXPRESSION_1.ptr = NUMEXPRESSION_1.inh
- NUMEXPRESSION_1.ptr depende apenas de NUMEXPRESSION_1.inh (herdado do pai)

3 - Bloco TERMS:

Produ√ß√£o:
TERM -> UNARYEXPRESSION TERM_1

Atributos
- UNARYEXPRESSION.ptr: sintetizado
- TERM_1.inh: herdado
- TERM.ptr: sintetizado

 TERM_1.inh = Node(TERM, vec![UNARYEXPRESSION.ptr])
 TERM.ptr = TERM_1.ptr
- TERM_1.inh depende de UNARYEXPRESSION.ptr, irm√£o √† esquerda
- TERM.ptr depende de TERM_1.ptr, filho √† direita 
 
Produ√ß√£o:
TERM_1 -> OP_TERM UNARYEXPRESSION TERM_1

Atributos:
- TERM_1.inh: herdado
- OP_TERM.ptr: sintetizado
- UNARYEXPRESSION.ptr: sintetizado
- TERM_1_1.inh: herdado
- TERM_1.ptr: sintetizado

 TERM_1_1.inh = Node(TERM, vec![TERM_1.inh.children[0], OP_TERM.ptr, UNARYEXPRESSION.ptr])
 TERM_1.ptr = TERM_1_1.ptr
- TERM_1_1.inh depende de:
  - TERM_1.inh (herdado do pai)
  - OP_TERM.ptr (filho √† esquerda)
  - UNARYEXPRESSION.ptr (filho √† esquerda de TERM_1_1)
- TERM_1.ptr depende de TERM_1_1.ptr (filho √† direita) 

Produ√ß√£o:
TERM_1 -> ''

Atributos:
- TERM_1.inh: herdado
- TERM_1.ptr: sintetizado
 
 TERM_1.ptr = TERM_1.inh
- TERM_1.ptr depende apenas de TERM_1.inh (herdado do pai)

4 - Bloco UNARYEXPRESSION

Produ√ß√£o:
UNARYEXPRESSION -> FACTOR

Atributos:
- FACTOR.ptr: sintetizado
- UNARYEXPRESSION.ptr: sintetizado

 UNARYEXPRESSION.ptr = Node(UNARYEXPRESSION, vec![FACTOR.ptr])
- UNARYEXPRESSION.ptr depende de FACTOR.ptr (filho)

Produ√ß√£o:
UNARYEXPRESSION -> OP_NUMEXPRESSION FACTOR

Atributos:
- OP_NUMEXPRESSION.ptr: sintetizado
- FACTOR.ptr: sintetizado
- UNARYEXPRESSION.ptr: sintetizado

 UNARYEXPRESSION.ptr = Node(UNARYEXPRESSION, vec![OP_NUMEXPRESSION.ptr, FACTOR.ptr])
UNARYEXPRESSION.ptr depende de:
- OP_NUMEXPRESSION.ptr (filho √† esquerda)
- FACTOR.ptr (filho √† direita)

5 - Bloco FACTOR

Produ√ß√£o:
FACTOR -> CONSTANT

Atributos:
- CONSTANT.ptr: sintetizado
- FACTOR.ptr: sintetizado

 FACTOR.ptr = Node(FACTOR, vec![CONSTANT.ptr])
- FACTOR.ptr depende de CONSTANT.ptr (filho)

Produ√ß√£o:
FACTOR -> LVALUE

Atributos:
- LVALUE.ptr: sintetizado
- FACTOR.ptr: sintetizado

 FACTOR.ptr = Node(FACTOR, vec![LVALUE.ptr])
- FACTOR.ptr depende de LVALUE.ptr (filho)

Produ√ß√£o:
FACTOR -> lparenthesis NUMEXPRESSION rparenthesis

Atributos:
- NUMEXPRESSION.ptr: sintetizado
- FACTOR.ptr: sintetizado

 FACTOR.ptr = Node(FACTOR, vec![NUMEXPRESSION.ptr])
- FACTOR.ptr depende de NUMEXPRESSION.ptr (filho)

Produ√ß√£o:
LVALUE -> id VAR_INDEX

Atributos:
- id.val: valor l√©xico do terminal
- VAR_INDEX.inh: herdado
- VAR_INDEX.ptr: sintetizado
- LVALUE.ptr: sintetizado

 VAR_INDEX.inh = id.val
 LVALUE.ptr = Node(LVALUE, vec![VAR_INDEX.ptr])

- VAR_INDEX.inh depende de id.val (irm√£o √† esquerda)
- LVALUE.ptr depende de VAR_INDEX.ptr (filho)

Produ√ß√£o:
VAR_INDEX -> ''

Atributos:
- VAR_INDEX.inh: herdado
- VAR_INDEX.ptr: sintetizado

 VAR_INDEX.ptr = Node(LVALUE, vec![VAR_INDEX.inh])
- VAR_INDEX.ptr depende apenas de VAR_INDEX.inh (herdado do pai)

Somente atributos sintetizados:
CONSTANT -> const_int
 CONSTANT.ptr = Node(CONSTANT, const_int.val)
CONSTANT -> const_float
 CONSTANT.ptr = Node(CONSTANT, const_float.val)
CONSTANT -> const_string
 CONSTANT.ptr = Node(CONSTANT, const_string.val)
CONSTANT -> const_null
 CONSTANT.ptr = Node(CONSTANT, 0)

Cada produ√ß√£o da gram√°tica aceita uma defini√ß√£o de atributos herdados (somente do pai ou dos irm√£os √† esquerda) e sintetizados (com base nos filhos) que respeita estritamente as restri√ß√µes de uma SDD L-atribu√≠da. 
Portanto, a gram√°tica √© compat√≠vel com uma defini√ß√£o dirigida pela sintaxe L-atribu√≠da.



