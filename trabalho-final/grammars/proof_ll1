Queremos provar que a gram√°tica ConvCC-2025-1 G admite uma defini√ß√£o dirigida pela sintaxe L-atribu√≠da (SDD L-atribu√≠da).

Uma defini√ß√£o dirigida pela sintaxe (SDD) √© dita L-atribu√≠da se:

1 - Para cada produ√ß√£o A -> X1, X2,...Xn, qualquer atributo herdado de Xi, i‚àà [1,n] ) pode depender apenas de atributos herdados ou sintetizados do s√≠mbolo pai A e atributos sintetizados de s√≠mbolos √† esquerda de Xi, ou seja, X1, X2,...Xi-1;
2 - Atributos sintetizados de um s√≠mbolo A podem depender apenas de atributos dos s√≠mbolos X1,...,Xn na produ√ß√£o.

3 - Portanto, G admite uma defini√ß√£o L-atribu√≠da.


Parte 1: A gram√°tica √© compat√≠vel com parsing LL(1):

Seja G = (Vn, Vt, P, S) uma gram√°tica livre de contexto, com:
- Vn: conjunto de n√£o terminais;
- Vt: conjunto de s√≠mbolos terminais;
- P: conjunto de produ√ß√µes;
- S: s√≠mbolo inicial
Dizemos que G √© uma gram√°tica LL(1) se e somente se, para cada n√£o-terminal A ‚àà V e para cada par de produ√ß√µes distintas: A ->  ùõº e A -> ùõΩ, com ùõº != ùõΩ, valem as seguintes condi√ß√µes:
1 - FIRST(ùõº) ‚à© FIRST(ùõΩ)
2 - Se ùúñ ‚àà FIRST(ùõº), ent√£o FIRST(ùõΩ) ‚à© FOLLOW(S) = ‚àÖ
3 - Se ùúñ ‚àà FIRST(ùõΩ), ent√£o FIRST(ùõº) ‚à© FOLLOW(S) = ‚àÖ

Assim, ao examinar o pr√≥ximo token de entrada (lookahead de 1 s√≠mbolo), √© poss√≠vel decidir unicamente qual produ√ß√£o aplicar, requisito para a an√°lise descendente determin√≠stica.

 Parte 2 ‚Äî A gram√°tica admite uma defini√ß√£o dirigida pela sintaxe L-atribu√≠da

Seja uma gram√°tica G = (Vn, Vt, P, S). Uma Defini√ß√£o Dirigida pela Sintaxe (SDD) √© dita L-atribu√≠da se, para cada produ√ß√£o da forma: 
A -> X1, X2,...Xn,
e para cada atributo herdado h de algum s√≠mbolo Xi, a fun√ß√£o de avalia√ß√£o de h pode depender somente de atributos (sintetizados ou herdados) de 
- A (o s√≠mbolo do lado esquerdo da produ√ß√£o);
- Atributos sintetizados de X1, X2,...Xi-1 (os irm√£os √† esquerda de Xi).
Estas restri√ß√µes garantem que os atributos podem ser avaliados em uma √∫nica travessia da √°rvore sint√°tica da esquerda para a direita. 

1 - Produ√ß√µes com apenas atributos sintetizados

PROGRAM -> FUNCLIST
 PROGRAM.scopes.push(ScopeType::ANY)
PROGRAM -> STATEMENT
 PROGRAM.scopes.push(ScopeType::ANY)
VARDECL -> vartype id
 VARDECL.scopes.insert(id.val, vartype.val)
 
CONST_INDEX -> lbracket const_int rbracket CONST_INDEX
CONST_INDEX -> ''
VAR_INDEX -> lbracket NUMEXPRESSION rbracket VAR_INDEX

VAR_INDEX -> ''
    VAR_INDEX.ptr = Node(LVALUE, vec![VAR_INDEX.inh])

UNARYEXPRESSION -> FACTOR
    UNARYEXPRESSION.ptr = Node(UNARYEXPRESSION, vec![FACTOR.ptr])
UNARYEXPRESSION -> OP_NUMEXPRESSION FACTOR
    UNARYEXPRESSION.ptr = Node(Some(Box::new(self.children[0].visit(None))), 
                              Box::new(self.children[1].visit(None)))
                              
FACTOR -> CONSTANT
    FACTOR.ptr = Node(FACTOR, vec![CONSTANT.ptr])
FACTOR -> LVALUE
    FACTOR.ptr = Node(FACTOR, vec![LVALUE.ptr])
FACTOR -> lparenthesis NUMEXPRESSION rparenthesis
    FACTOR.ptr = Node(FACTOR, vec![NUMEXPRESSION.ptr])
ALLOCEXPRESSION ‚Üí kw_new var_type VAR_INDEX

2 - Produ√ß√µes com atributos herdados de pai e irm√£o √† esquerda

FUNCLIST ‚Üí FUNCDEF FUNCLIST
FUNCLIST ‚Üí ''
PARAMLIST -> var_type id PARAMLIST_1
    PARAMLIST_1.inh = vec![var_type, id]
    PARAMLIST.ptr = PARAMLIST_1.ptr
PARAMLIST -> ''
    PARAMLIST.ptr = vec![]

PARAMLIST_1 -> comma var_type id PARAMLIST_1
    PARAMLIST_1_1.inh = PARAMLIST_1.inh + vec![var_type, id]
    PARAMLIST_1.ptr = PARAMLIST_1_1.ptr
PARAMLIST_1 -> ''
    PARAMLIST_1.ptr = Node(PARAMLIST, PARAMLIST_1.inh)
 
EXPRESSION -> NUMEXPRESSION EXPRESSION_1
    EXPRESSION_1.inh = NUMEXPRESSION.ptr
    EXPRESSION.ptr = EXPRESSION_1.ptr

EXPRESSION_1 -> OP_EXPRESSION NUMEXPRESSION
    EXPRESSION_1.ptr = Node(Box::new(inh.unwrap()[0].clone()), 
                          Some(Box::new(self.children[0].visit(None))),
                          Some(Box::new(self.children[1].visit(None))))
EXPRESSION_1 -> ''
    EXPRESSION_1.ptr = Node(Box::new(inh.unwrap()[0].clone()), 
                          None,
                          None)

NUMEXPRESSION -> TERM NUMEXPRESSION_1
    NUMEXPRESSION_1.inh = Node(NUMEXPRESSION, vec![TERM.ptr])
    NUMEXPRESSION.ptr = NUMEXPRESSION_1.ptr
NUMEXPRESSION_1 -> OP_NUMEXPRESSION TERM NUMEXPRESSION_1
    NUMEXPRESSION_1_1.inh = Node(Box::new(inh.unwrap()[0].clone()), 
                                Some(Box::new(self.children[0].visit(None))),
                                Some(Box::new(self.children[1].visit(None))))
 NUMEXPRESSION_1.ptr = NUMEXPRESSION_1_1.ptr
NUMEXPRESSION_1 -> ''
    NUMEXPRESSION_1.ptr = NUMEXPRESSION_1.inh

TERM -> UNARYEXPRESSION TERM_1
    TERM_1.inh = Node(TERM, vec![UNARYEXPRESSION.ptr])
    TERM.ptr = TERM_1.ptr
 
TERM_1 -> OP_TERM UNARYEXPRESSION TERM_1
    TERM_1_1.inh = Node(Box::new(inh.unwrap()[0].clone()),
                                Some(Box::new(self.children[0].visit(None))), 
                               Some(Box::new(self.children[1].visit(None))))
    TERM_1.ptr = TERM_1_1.ptr
TERM_1 -> ''
    TERM_1.ptr = TERM_1.inh

3 - Heran√ßa do pai, s√≠ntese dos filhos

FUNCDEF -> kw_def func_id ( PARAMLIST ) { STATELIST }
 STATELIST.scopes.push(ScopeType::Function)
 PARAMLIST.scopes.insert(PARAMLIST.values)
 
STATELIST -> STATEMENT STATELIST_1
    STATELIST_1.inh = vec![STATEMENT.ptr]
    STATELIST.ptr = STATELIST_1.ptr

STATELIST_1 -> STATEMENT STATELIST_1
    STATELIST_1_1.inh = STATELIST_1.inh + vec![STATEMENT.ptr]
    STATELIST_1.ptr = STATELIST_1_1.ptr
STATELIST_1 -> ''
    STATELIST_1.ptr = Node(STATELIST, STATELIST_1.inh)

ATRIBSTAT ‚Üí LVALUE = ATRIBSTATEVALUE
ATRIBSTATEVALUE ‚Üí EXPRESSION
ATRIBSTATEVALUE ‚Üí ALLOCEXPRESSION
ATRIBSTATEVALUE ‚Üí FUNCCALL
FUNCCALL ‚Üí func_id ( PARAMLISTCALL )
PARAMLISTCALL ‚Üí ''
PARAMLISTCALL ‚Üí id PARAMLISTCALL_1
PARAMLISTCALL_1 ‚Üí , id PARAMLISTCALL_1
PARAMLISTCALL_1 ‚Üí ''
PRINTSTAT ‚Üí kw_print EXPRESSION
READSTAT ‚Üí kw_read LVALUE
IFSTAT -> kw_if lparenthesis EXPRESSION rparenthesis lbrace STATELIST rbrace ELSESTAT
    STATELIST.scopes.push(ScopeType::Any)

ELSESTAT_1 -> lbrace STATELIST rbrace
    STATELIST.scopes.push(ScopeType::Any)

ELSESTAT ‚Üí ''
ELSESTAT_1 ‚Üí IFSTAT
ELSESTAT_1 ‚Üí { STATELIST }
PRINTSTAT ‚Üí kw_print EXPRESSION
READSTAT ‚Üí kw_read LVALUE

4 - Heran√ßa do pai, s√≠ntese direta/ local

STATEMENT ‚Üí VARDECL semicolon
STATEMENT ‚Üí ATRIBSTAT semicolon
STATEMENT ‚Üí PRINTSTAT semicolon
STATEMENT ‚Üí READSTAT semicolon
STATEMENT ‚Üí RETURNSTAT semicolon
STATEMENT ‚Üí IFSTAT
STATEMENT ‚Üí FORSTAT
STATEMENT ‚Üí { STATELIST }
STATEMENT ‚Üí kw_break semicolon
STATEMENT ‚Üí semicolon
FORSTAT ‚Üí kw_for ( ATRIBSTAT ; EXPRESSION ; ATRIBSTAT ) { STATELIST }
LVALUE ‚Üí id VAR_INDEX
CONSTANT ‚Üí const_int | const_float | const_string | const_null
OP_EXPRESSION -> op_eq
    OP_EXPRESSION.ptr = Node(op_eq, None)
OP_EXPRESSION -> op_ne
 OPERACAO.ptr = Node(op_ne, None)
OP_EXPRESSION -> op_ge
 OP_EXPRESSION.ptr = Node(op_ge, None)
OP_EXPRESSION -> op_gt
 OP_EXPRESSION.ptr = Node(op_gt, None)
OP_EXPRESSION -> op_le
 OP_EXPRESSION.ptr = Node(op_le, None)
OP_EXPRESSION -> op_lt
 OP_EXPRESSION.ptr = Node(op_lt)

OP_NUMEXPRESSION -> op_plus
 OP_NUMEXPRESSION.ptr = Node(op_plus, None)
OP_NUMEXPRESSION -> op_minus
 OP_NUMEXPRESSION.ptr = Node(op_minus, None)
 
OP_TERM -> op_mutl
 OP_TERM.ptr = Node(op_mult, None)
OP_TERM -> op_division
 OP_TERM.ptr = Node(op_division, None)
OP_TERM -> op_modular
 OP_TERM.ptr = Node(op_modular, None)

5 - Trivial

RETURNSTAT ‚Üí kw_return

Cada produ√ß√£o da gram√°tica aceita uma defini√ß√£o de atributos herdados (somente do pai ou dos irm√£os √† esquerda) e sintetizados (com base nos filhos) que respeita estritamente as restri√ß√µes de uma SDD L-atribu√≠da. Portanto, a gram√°tica √© compat√≠vel com uma defini√ß√£o dirigida pela sintaxe L-atribu√≠da.







