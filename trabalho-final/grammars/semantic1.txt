# Rust structures to be used by the rules
enum NodeType {
  EXPRESSION,
  NUMEXPRESSION,
  TERM,
  FACTOR,
  (all of the terminals envolved)
}

struct Node {
  node_type: NodeType,
  children: Option<Vec<Node>>
}

PARAMLIST -> var_type id PARAMLIST_1
 PARAMLIST_1.inh = vec![var_type, id]
 PARAMLIST.ptr = PARAMLIST_1.ptr
PARAMLIST -> ''
 PARAMLIST.ptr = vec![]

PARAMLIST_1 -> comma var_type id PARAMLIST_1
 PARAMLIST_1_1.inh = PARAMLIST_1.inh + vec![var_type, id]
 PARAMLIST_1.ptr = PARAMLIST_1_1.ptr
PARAMLIST_1 -> ''
 PARAMLIST_1.ptr = Node(PARAMLIST, PARAMLIST_1.inh)

STATELIST -> STATEMENT STATELIST_1
 STATELIST_1.inh = vec![STATEMENT.ptr]
 STATELIST.ptr = STATELIST_1.ptr

STATELIST_1 -> STATEMENT STATELIST_1
 STATELIST_1_1.inh = STATELIST_1.inh + vec![STATEMENT.ptr]
 STATELIST_1.ptr = STATELIST_1_1.ptr
STATELIST_1 -> ''
 STATELIST_1.ptr = Node(STATELIST, STATELIST_1.inh)

# Semantic rules
# TODO: Provar que essa SDD é L-atribuída
# TODO: Substituir vetores por (esquerda, operação, direita)
EXPRESSION -> NUMEXPRESSION EXPRESSION_1
 EXPRESSION_1.inh = NUMEXPRESSION.ptr
 EXPRESSION.ptr = EXPRESSION_1.ptr

EXPRESSION_1 -> OP_EXPRESSION NUMEXPRESSION
 EXPRESSION_1.ptr = Node(EXPRESSION, Some(vec![EXPRESSION_1.inh, OP_EXPRESSION.ptr, NUMEXPRESSION.ptr]))

EXPRESSION_1 -> ''
 EXPRESSION_1.ptr = Node(EXPRESSION, Some(vec![EXPRESSION_1.inh]))

NUMEXPRESSION -> TERM NUMEXPRESSION_1
 NUMEXPRESSION_1.inh = Node(NUMEXPRESSION, vec![TERM.ptr])
 NUMEXPRESSION.ptr = NUMEXPRESSION_1.ptr

NUMEXPRESSION_1 -> OP_NUMEXPRESSION TERM NUMEXPRESSION_1
 NUMEXPRESSION_1_1.inh = Node(NUMEXPRESSION, vec![NUMEXPRESSION_1.inh.children[0], OP_NUMEXPRESSION.ptr, TERM.ptr])
 NUMEXPRESSION_1.ptr = NUMEXPRESSION_1_1.ptr

NUMEXPRESSION_1 -> ''
 NUMEXPRESSION_1.ptr = NUMEXPRESSION_1.inh

TERM -> UNARYEXPRESSION TERM_1
 TERM_1.inh = Node(TERM, vec![UNARYEXPRESSION.ptr])
 TERM.ptr = TERM_1.ptr
 
TERM_1 -> OP_TERM UNARYEXPRESSION TERM_1
 TERM_1_1.inh = Node(TERM, vec![TERM_1.inh.children[0], OP_TERM.ptr, UNARYEXPRESSION.ptr])
 TERM_1.ptr = TERM_1_1.ptr

TERM_1 -> ''
 TERM_1.ptr = TERM_1.inh

UNARYEXPRESSION -> FACTOR
 UNARYEXPRESSION.ptr = Node(UNARYEXPRESSION, vec![FACTOR.ptr])
UNARYEXPRESSION -> OP_NUMEXPRESSION FACTOR
 UNARYEXPRESSION.ptr = Node(UNARYEXPRESSION, vec![OP_NUMEXPRESSION.ptr, FACTOR.ptr])

OP_EXPRESSION -> op_eq
 OP_EXPRESSION.ptr = Node(op_eq, None)
OP_EXPRESSION -> op_ne
 OPERACAO.ptr = Node(op_ne, None)
OP_EXPRESSION -> op_ge
 OP_EXPRESSION.ptr = Node(op_ge, None)
OP_EXPRESSION -> op_gt
 OP_EXPRESSION.ptr = Node(op_gt, None)
OP_EXPRESSION -> op_le
 OP_EXPRESSION.ptr = Node(op_le, None)
OP_EXPRESSION -> op_lt
 OP_EXPRESSION.ptr = Node(op_lt)

OP_NUMEXPRESSION -> op_plus
 OP_NUMEXPRESSION.ptr = Node(op_plus, None)
OP_NUMEXPRESSION -> op_minus
 OP_NUMEXPRESSION.ptr = Node(op_minus, None)

OP_TERM -> op_mutl
 OP_TERM.ptr = Node(op_mult, None)
OP_TERM -> op_division
 OP_TERM.ptr = Node(op_division, None)
OP_TERM -> op_modular
 OP_TERM.ptr = Node(op_modular, None)

FACTOR -> CONSTANT
 FACTOR.ptr = Node(FACTOR, vec![CONSTANT.ptr])
FACTOR -> LVALUE
 FACTOR.ptr = Node(FACTOR, vec![LVALUE.ptr])
FACTOR -> lparenthesis NUMEXPRESSION rparenthesis
 FACTOR.ptr = Node(FACTOR, vec![NUMEXPRESSION.ptr])

CONSTANT -> const_int
 CONSTANT.ptr = Node(CONSTANT, const_int.val)
CONSTANT -> const_float
 CONSTANT.ptr = Node(CONSTANT, const_float.val)
CONSTANT -> const_string
 CONSTANT.ptr = Node(CONSTANT, const_string.val)
CONSTANT -> const_null
 CONSTANT.ptr = Node(CONSTANT, 0)

LVALUE -> id VAR_INDEX
 VAR_INDEX.inh = id.val
 LVALUE.ptr = Node(LVALUE, vec![VAR_INDEX.ptr])

VAR_INDEX -> lbracket NUMEXPRESSION rbracket VAR_INDEX

VAR_INDEX -> ''
 VAR_INDEX.ptr = Node(LVALUE, vec![VAR_INDEX.inh])


